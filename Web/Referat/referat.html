<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible"
        content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1">
  <meta name="description"
        content="">
  <meta name="author"
        content="">

  <title>JSON Web Token</title>

  <link href="css/bootstrap.min.css"
        rel="stylesheet">

  <link href="css/styles.css"
        rel="stylesheet">

</head>

<body>

  <div id="sidebar-wrapper">
    <p class="lead">JSON Web Token</p>
    <ul class="list-group sidebar-nav">
      <li>
        <a href="#introduction"
           class="list-group-item navigation-btn active">Какво е JWT?</a>
      </li>
      <li>
        <a href="#structure"
           class="list-group-item navigation-btn">Структура</a>
      </li>
      <li>
        <a href="#usage"
           class="list-group-item navigation-btn">Как се използва?</a>
      </li>
      <li>
        <a href="#data-protection"
           class="list-group-item navigation-btn">Защита на данни</a>
      </li>
      <li>
        <a href="#verification"
           class="list-group-item navigation-btn">Верифициране на JWT</a>
      </li>
      <li>
        <a href="#comparison"
           class="list-group-item navigation-btn">Сравнение с други начини за аутентикация</a>
      </li>
      <li>
        <a href="#jws"
           class="list-group-item navigation-btn">JSON Web Signature</a>
      </li>
      <li>
        <a href="#jwe"
           class="list-group-item navigation-btn">JSON Web Encryption</a>
      </li>
      <li>
        <a href="#jwa"
           class="list-group-item navigation-btn">JSON Web Algorithms</a>
      </li>
    </ul>
  </div>
  <div class="container page-content">
    <div class="thumbnail"
         id="introduction">
      <div class="caption-full">
        <h3>
          Какво е JWT?
        </h3>

        <p>JSON Web Token (JWT) е компактен, URL-безопасен начин за представяне на искове, които са обект на трансфер между
          две страни. Исковете в един JWT са кодирани във формат на JSON обект, който се използва като товара на JSON Web
          Signature (JWS) структура или като текстовото съдържание на JSON Web Encryption (JWE) структура, и позволява исковете
          да бъдат подписани дигитално или тяхната цялост да бъде защитена с Message Authentication Code (MAC). Също така
          могат да бъдат криптирани.
        </p>

        <p>
          <strong> JWT работи с различни програмни езици:</strong> .NET, Python, Node.js, Java, PHP, Ruby, Go, JavaScript, и Haskell.
          Вижда се, че може да бъде използван в много различни сценарии.
        </p>

        <p>
          <strong> JWT е самостоятелен:</strong> Всичката нужна информация се съдържа в него. Това означава, че един JWT е способен
          да пренася основна информация за себе си, товар (обикновено информация за потребителя) и подпис.
        </p>

        <p>
          <strong> JWTs се предават по мрежата лесно:</strong> След като JWT е самостоятелен и всичката информация се съдържа в него,
          те могат лесно да се използват в HTTP header, когато се аутентикира API. Също така могат да се предават и през
          URL-а на страницата.
        </p>
      </div>
    </div>

    <div class="thumbnail"
         id="structure">
      <div class="caption-full">
        <h3>
          Структура
        </h3>

        <p>
          Всеки JSON Web Token съдържа три елемента:
          <ul class="list-unstyled">
            <li>
              <a href="#structure-header">header</a>
            </li>
            <li>
              <a href="#structure-payload">payload</a>
            </li>
            <li>
              <a href="#structure-signature">signature</a>
            </li>
          </ul>
        </p>
        <div id="structure-header">
          <h4>
            Заглавие (header)
          </h4>

          <p>
            Съставен от 2 части:
            <ul>
              <li>typ - показва типа, който обикновено е "JWT"</li>
              <li>alg - алгоритъма, използван за хеширане</li>
            </ul>

            <pre>
  {
    "typ": "JWT",
    "alg": "HS256"
  }             </pre>
            <h6 class="text-center">Пример 1 - заглавие на JWT</h6>
          </p>

        </div>
        <div id="structure-payload">
          <hr>
          <h4>
            Товар (payload)
          </h4>

          <p>
            Товарът представлява голяма част от JWT, още наричан JWT искове (claims). В него се съдържа информацията, която се предава,
            както и други данни за token-а. </p>
          <p>Има няколко искове, които се подават. Това включва регистрирани имена (registered claim names), публични имена
            (public claim names) и вътрешни имена (private claim names).
          </p>

          <pre>
  {
    "iss": "mayapp",
    "exp": 1300819380,
    "name": "John Doe",
    "admin": true
  }</pre>
          <h6 class="text-center">Пример 2 - товар на JWT</h6>
        </div>
        <div id="structure-signature">
          <hr>

          <h4>Подпис (signature)</h4>

          <p>
            Третата и последна част от JSON Web Token е подписа (signature). Той е получен при хеширане на следните компоненти:
            <ul>
              <li>header</li>
              <li>payload</li>
              <li>secret (таен ключ)</li>
            </ul>
            Така се получава третата част:

            <pre>var encodedString = base64UrlEncode(header) + "." + base64UrlEncode(payload);
                  
HMACSHA256(encodedString, 'secret'); // gV0zIGm6ND8aDaBA45i7NEFfg7xJ-eYvDu4LYYieaNM </pre>
            <h6 class="text-center">Пример 3 - подпис на JWT</h6>
            Тайният ключ (secret) се пази от сървъра. С него нашето приложение ще може да верифицира съществуващи JWT, както и да подписва
            нови.
          </p>
        </div>
        <hr>

        <div>
          <p>
            JSON Web Token се получава със следните стъпки:
            <ul>
              <li>header елемента се кодира в base64</li>
              <li>payload елемента се кодира в base 64</li>
              <li>
                Резултата от кодирането на header и payload елементите се слагат един до друг и се добавя '.' между тях. Полученият низ след
                това бива хеширан със тайния ключ и така се получава signature елемента.
              </li>
              <li>
                Самият JWT се получава при събиране на трите низа и добавяне на точки между тях.
              </li>
            </ul>

            <pre>// JWT Token
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</pre>
            <br>
            <img src="img/structure.png"
                 alt="structure"
                 id="image">
            <h6 class="text-center">Фигура 1 - структура</h6>
          </p>
        </div>
      </div>
    </div>

    <div class="thumbnail"
         id="usage">
      <div class="caption-full">
        <h3>
          Как се използва?
        </h3>

        <p>
          За да покаже защо и как се използва JWT, е подготвен пример с 3 главни действащи лица - потребител, приложение и аутентикиращ
          сървър (долната диаграма). Аутентикиращият сървър ще предостави JSON Web Token на потребителя, с който той може
          да комуникира с приложението.
        </p>
        <img src="img/usage.png"
             alt="structure"
             id="image">
        <h6 class="text-center">Фигура 2 - начин на действие [3]</h6>
        <p>
          В този пример, потребителят първо се вписва в аутентикиращия сървър, използвайки нужните данни (потребителско име и парола,
          Facebook, Google ...). След това този сървър създава JWT и го изпраща към потребителя. Когато потребителят праща
          HTTP заявки към API-то на приложението, подава и JSON Web Token-а. В този случай, приложението ще бъде конфигурирано
          така, че да верифицира че пристигащият JWT е създаден от достоверен източник. Така вече, когато потребителят прави
          заявки към приложението със закачен JWT, приложението може да верифицира, че тези заявки идват от аутентикиран
          потребител.
        </p>
      </div>
    </div>

    <div class="thumbnail"
         id="data-protection">
      <div class="caption-full">
        <h3>
          Защита на данни
        </h3>

        <p>
          Важно е да се разбере, че целта на използването на JWT не е да крие ценни данни по никакъв начин. Причината за използването
          на token-а е да покаже, че изпратените данни са всъщност създадени от автентичен източник (сървъра).
        </p>
        <p>
          Данните в JWT са кодирани и подписани, но не са криптирани. Целта на кодирането на данните е да се промени структурата им
          и те да станат във вид, по-лесен за пренасяне. Подписването на данните се прави, за да може получателят да верифицира
          автентичността на източника на данните. Кодирането и подписването на данните не гарантира тяхната защита. Основната
          цел на криптирането е да подсигури данните и да предотврати неоторизиран достъп.
        </p>
        <h4>
          <strong>
            След като JSON Web Token е само подписан и кодиран, а не криптиран, не гарантира никаква защита на ценни данни.
          </strong>
        </h4>

        <p>

        </p>
      </div>
    </div>

    <div class="thumbnail"
         id="verification">
      <div class="caption-full">
        <h3>
          Верифициране на JWT
        </h3>

        <p>
          В нашият прост пример използваме JWT, подписан от HS256 алгоритъм и само сървъра знае какъв е тайният ключ. Когато потребителят
          направи HTTP заявка със добавен JSON Web Token към API-то на приложението (сървъра), то може да извърши същата
          операция по хеширане. След това може да верифицира, че хешът получен от операцията е същият като този в token-а.
          Ако съвпадат, то означава че JWT е валиден и показва, че HTTP заявката идва от оторизиран потребител. Ако не съвпадат,
          значи JSON Web Token-а е невалиден и може да е знак, че има потенциална атака към приложението. Като валидира JWT,
          приложението добавя слой на доверие между себе си и потребителя.
        </p>
      </div>
    </div>

    <div class="thumbnail"
         id="comparison">
      <div class="caption-full">
        <h3>
          Сравнение с други начини за аутентикация
        </h3>

        <p>
          For an API to be a powerful extension of a product, it almost certainly needs authentication. By building API calls that
          can read, write, and delete user data, you can magnify an app’s influence on its users’ lives. So, if authentication
          is a given, the method is the real choice. The industry has finally learned not to share usernames and passwords,
          but there’s still more to figure out.

        </p>
        <p>Below we’ll look at three popular authentication methods: API keys, OAuth access tokens, and JSON Web Tokens (JWT).
          We’ll cover how each is used and why you might choose one over the others.
        </p>

        <section>
          <h4>API Keys: Great for Developer Quickstart</h4>

          <p>In the earliest days of modern web APIs, the API key was all we had. It likely remains as the most common identifier,
            and is the first many developers consider when restricting or tracking API traffic. The best thing about an API
            key is its simplicity. You merely log in to a service, find your API key (often in the settings screen), and
            copy it to use in an application, test in the browser, or use with one of these API request tools. Along with
            the simplicity, though, comes both security and user experience downsides to API keys.</p>

          <img src="img/apikey.png"
               alt="api key"
               id="image">
          <h6 class="text-center">Фигура 3 - API Key [4]</h6>

          <p>Typically, an API key gives full access to every operation an API can perform, including writing new data or deleting
            existing data. If you use the same API key in multiple apps, a broken app could destroy your users' data without
            an easy way to stop just that one app. Some apps let users generate new API keys, or even have multiple API keys
            with the option to revoke one that may have gone into the wrong hands. The ability to change an API key limits
            the security downsides.
          </p>
          <p>
            Many API keys are sent in the query string as part of the URL, which makes it easier to discover for someone who should not
            have access to it. A better option is to put the API key in the Authorization header. In fact, that’s the proposed
            standard: Authorization: Apikey 1234567890abcdef
          </p>
          <p>
            Yet, in practice API keys show up in all sorts of places:
          </p>
          <ul>
            <li> Authorization Header</li>
            <li> Basic Auth</li>
            <li> Body Data</li>
            <li> Custom Header</li>
            <li> Query String</li>
          </ul>

          <p> The user experience of API keys is something to consider, as well. API keys make sense when the users of an API
            are only developers. However, as developers created tools for themselves, they started sharing them with others.
            End users often find themselves fumbling through API documentation, registration, and settings just to find the
            API key that a tool needs—often without even knowing what an API is.
          </p>
          <p>
            In the same way that Zapier user data showed the poor user experience of static webhooks, moving out of a flow to find API
            keys distract users from their desired purpose. Combine that with the security concerns and there are other much
            better approaches to access user data with APIs.</p>
        </section>
        <section>
          <h4>OAuth Tokens: Great for Accessing User Data</h4>

          <p>OAuth is the answer to accessing user data with APIs. Unlike with API keys, OAuth does not require a user to go
            spelunking through a developer portal. In fact, in the best cases, users simply click a button to allow an application
            to access their accounts. OAuth, specifically OAuth 2.0, is a standard for the process that goes on behind the
            scenes to ensure secure handling of these permissions.</p>

          <img src="img/oauth.png"
               alt="OAuth"
               id="image">
          <h6 class="text-center">Фигура 4 - OAuth [4]</h6>

          <p>The previous versions of this spec, OAuth 1.0 and 1.0a, were much more complicated than OAuth 2.0. The biggest
            change in the latest version is that it’s no longer required to sign each call with a keyed hash. The most common
            implementations of OAuth use one or both of these tokens instead:
          </p>
          <ul>
            <li>
              <strong> access token:</strong> sent like an API key, it allows the application to access a user’s data; optionally,
              access tokens can expire.</li>
            <li>
              <strong> refresh token:</strong> optionally part of an OAuth flow, refresh tokens retrieve a new access token if they
              have expired.</li>
          </ul>

          <p>Similar to API keys, you may find OAuth access tokens all over the place: in query string, headers, and elsewhere.
            Since an access token is like a special type of API key, the most likely place to put it is the authorization
            header, like so:
          </p>
          <pre>Authorization: Bearer 1234567890abcdef</pre>
          <p>
            The access and refresh tokens should not be confused with the Client ID and Client Secret. Those values, which may look like
            a similar random collection of characters, are used to negotiate access and refresh tokens.</p>

          <p>Like an API key, anyone with an access token can potentially invoke harmful operations, such as deleting data.
            However, OAuth provides several improvements over API keys. For starters, access tokens can be tied to particular
            scopes, which restrict the types of operations and data the application can access. Also, combined with refresh
            tokens, access tokens will expire, so the negative effects could have a limited impact. Finally, even if refresh
            tokens aren’t used, access tokens can still be revoked.</p>

          <h4>JWT Tokens: Great for Limiting Database Lookups</h4>

          <p>Whereas API keys and OAuth tokens are always used to access APIs, JSON Web Tokens (JWT) can be used in many different
            scenarios. In fact, JWT can store any type of data, which is where it excels in combination with OAuth. With
            a JWT access token, far fewer database lookups are needed while still not compromising security.</p>

          <p>While a JWT is longer than most access tokens, they’re still relatively compact (though this depends on how much
            data you store within them):</p>
          <pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJob21lcGFnZSI6Imh0dHBzOi8vemFwaWVyLmNvbSIsInRhZ2xpbmUiOiJaYXBpZXIgbWFrZXMgeW91IGhhcHBpZXIiLCJmb3JtIjoiaHR0cHM6Ly96YXBpZXIudHlwZWZvcm0uY29tL3RvL0hkRVk0eiJ9.E3EtYy2y7BRn4eS0RIyDAAh-KAsa6dVV91ULbBJCRJw</pre>
          <p>You’re able to avoid database lookups because the JWT contains a base64 encoded version of the data you need to
            determine the identity and scope of access. The JWT also contains a signature calculated using the JWT data.
            Using the same secret you used to produce the JWT, you calculate your own version of the signature and compare.
            This calculation is much more efficient than looking up an access token in a database to determine who it belongs
            to and whether it is valid.</p>
          <p>Like OAuth access tokens, JWT tokens should be passed in the Authorization header:</p>
          <pre>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJob21lcGFnZSI6Imh0dHBzOi8vemFwaWVyLmNvbSIsInRhZ2xpbmUiOiJaYXBpZXIgbWFrZXMgeW91IGhhcHBpZXIiLCJmb3JtIjoiaHR0cHM6Ly96YXBpZXIudHlwZWZvcm0uY29tL3RvL0hkRVk0eiJ9.E3EtYy2y7BRn4eS0RIyDAAh-KAsa6dVV91ULbBJCRJw</pre>
          <p>The downside of not looking up access tokens with each call is that a JWT cannot be revoked. For that reason, you’ll
            want to use JWT in combination with refresh tokens and JWT expiration. With each API call, you would need to
            check the JWT signature and ensure that the expiration is still in the future.</p>
        </section>

        <h4>Which Should I Use?</h4>

        <p></p>
        <ul>
          <li>
            <strong>
              Use API keys
            </strong>if you expect developers to build internal applications that don’t need to access more than a single
            user’s data.
          </li>
          <li>
            <strong>
              Use OAuth access tokens
            </strong>if you want users to easily provide authorization to applications without needing to share private data
            or dig through developer documentation.
          </li>
          <li>
            <strong>
              Use JWT
            </strong>in concert with OAuth if you want to limit database lookups and you don’t require the ability to immediately
            revoke access.
          </li>
        </ul>
      </div>
    </div>

    <div class="thumbnail"
         id="jws">
      <div class="caption-full">
        <h3>
          JSON Web Signature (JWS)
        </h3>

        <p>
          JSON Web Signature (JWS) представлява съдържание, подсигурено с дигитални подписи или с Message Authentication Codes (MAC),
          което използва JSON-базирани структури от данни. Криптографските механизми на JWS предоставят сигурност на цялостта
          за определена редица от октети.
        </p>
        <p>
          Две близки сериализации за JWS са дефинирани. JWS Компактна Сериализация (JWS Compact Serialization) е компактен, URL-безопасен
          начин за представяне, предназначен за среди с малко памет като HTTP Authorization Header и URI query параметри.
          JWS JSON Сериализацията (JWS JSON Serialization) представлява JWS като JSON обекти и позволява поставянето на няколко
          електронни подписа и/или MAC върху едно съдържание. И двете споделят едни и същи криптографски основи.
        </p>
        <p>
          JWT всъщност използва JWS за подписа си. Това означава, че JSON Web Token-а е JWS структура, която използва JSON обект като
          товара. Това също означава, че сигурността на цялостта не се ограничава до споделени тайни ключове, но и публичен/таен
          ключ тип криптография може да бъде използвана.
        </p>
      </div>
    </div>
    <div class="thumbnail"
         id="jwe">
      <div class="caption-full">
        <h3>
          JSON Web Encryption (JWE)
        </h3>

        <p>
          JSON Web Encryption (JWE) спецификацията стандартизира начина на представяне на криптирано съдържание в вид на JSON-базирана
          структура от данни. Тя дефинира две сериализирани форми за представяне на криптирания товар : JWE Компактна Сериализация
          (JWE Compact Serialization) и JWE JSON Сериализация (JWE JSON Serialization). Като в JWS, съобщението, което е
          криптирано използвайки JWE стандарта, не е нужно да бъде товар във вид JSON, а може да бъде всякакво.
        </p>
      </div>
    </div>
    <div class="thumbnail"
         id="jwa">
      <div class="caption-full">
        <h3>
          JSON Web Algorithms (JWA)
        </h3>

        <p>
          Тази спецификация регистрира криптографски алгоритми и идентификатори, които могат да се използват заедно със JSON Web Signature
          (JWS), JSON Web Encryption (JWE), and JSON Web Key (JWK) спецификациите. Тя дефинира няколко IANA регистъра за
          тези идентификатори. Тази спецификация също описва семантиките и операциите, специфични за тези алгоритми.
        </p>

        <p>
          Най-използваните алгоритми за подписване са:
          <ul>
            <li>HMAC + SHA256</li>
            <li>RSASSA-PKCS1-v1_5 + SHA256</li>
            <li>ECDSA + P-256 + SHA256</li>
          </ul>
        </p>

        <hr>

        <h4>HMAC алгоритми</h4>

        <p>Най-използваният алгоритъм за подписване на JWT.</p>

        <p> Хешово-базирани кодове за аутентикация на кодове (Hash-Based Message Authentication Codes - HMAC) е група алгоритми,
          която предоставя начин за подписване на съобщения чрез споделен ключ. Тук се използва криптографска хешираща функция
          (например SHA256). Нивото на сигурност (колко трудно е да се разбие HMAC) зависи от алгоритъма за хеширане, който
          се използва.</p>

        <p>Главната цел при дизайна на този алгоритъм е да позволи изполването на комбинация от ключ и съобщение, докато предоставя
          сигурност срещу пробиване. Наивни решения (например добавянето на ключа към съобщението и хеширане на резултата)
          страдат от математически закони, които позволяват на потенциални нападатели да пробият подписа. HMAC алгоритмите
          са измислени против това.
        </p>

        <p>HMAC алгоритмите се използват в JWT, когато се желае лесен начин за всички страни да създават и валидират token-и.
          Всяка страна, която знае ключа, може да създава JSON Web Token-и. При споделените ключове, е възможно една страна
          да се представи за друга - HMAC JWT не предоставят гаранции относно създателя. За някои случаи, това е прекалено
          свободно и в такъв случай се използват асиметрични ключове.</p>

        <hr>

        <h4>RSA и ECDSA алгоритми</h4>

        <p> RSA и ECDSA алгоритмите са по-сложни от HMAC. </p>

        <p>RSA и ECDSA са асиметрични алгоритми за дигитално подписване и криптиране. Предимството на асиметричните алгоритмите
          е възможността за верифицирането или декриптирането на съобщение, без да може да създава ново. Има случаи, в които
          възможността да се верифицира създателя на един подпис е първостепенно важна. JWT, подписани или криптирани с RSA
          или ECDSA предоставят тази функционалност. Алгоритмите използват таен ключ за създаването на token-а, но тя може
          да бъде верифицирана с публичният ключ (който трябва да е споделен както HMAC ключ). Страните, които получават
          JSON Web Token-а не могат да създават нови с публичният ключ на изпращача.</p>

        <p>Главната разлика между RSA и ECDSA е в скоростта и големината на ключа. ECDSA изисква по-малки ключове за постигане
          на същото ниво на сигурност като RSA. Това има смисъл при малки на размер JSON Web Token-и. RSA обикновено е по-бърз
          от ECDSA. Препоръчва се използването на този алгоритъм, който се вписва най-добре с изискванията на проекта, в
          който се изполват.</p>
      </div>
      <hr>
      <footer>
        <div class="row">
          <div class="col-lg-12">
            <h3> Източници:</h3>
            <ul class="list-group">
              <li class="list-group-item">
                <a href="https://tools.ietf.org/html/rfc7519"
                   target="_blank">[1] - JSON Web Token (JWT)</a>
              </li>
              <li class="list-group-item">
                <a href="https://scotch.io/tutorials/the-anatomy-of-a-json-web-token"
                   target="_blank">[2] - The Anatomy of a JSON Web Token </a>
              </li>
              <li class="list-group-item">
                <a href="https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec"
                   target="_blank">[3] - 5 Easy Steps to Understanding JSON Web Tokens (JWT)</a>
              </li>
              <li class="list-group-item">
                <a href="https://zapier.com/engineering/apikey-oauth-jwt/"
                   target="_blank">[4] - API Keys vs OAuth Tokens vs JSON Web Tokens</a>
              </li>
              <li class="list-group-item">
                <a href="https://tools.ietf.org/html/rfc7515"
                   target="_blank">[5] - JSON Web Signature (JWS)</a>
              </li>
              <li class="list-group-item">
                <a href="https://stackoverflow.com/questions/27640930/what-is-the-difference-between-json-web-signature-jws-and-json-web-token-jwt"
              
                   target="_blank">[6] - What is the difference between JSON Web Signature (JWS) and JSON Web Token (JWT)?</a>
              </li>
              <li class="list-group-item">
                <a href="https://tools.ietf.org/html/rfc7516"
                   target="_blank">[7] - JSON Web Encryption (JWE)</a>
              </li>
              <li class="list-group-item">
                <a href="https://tools.ietf.org/html/rfc7518#section-1"
                   target="_blank">[8] - JSON Web Algorithms (JWA)</a>
              </li>
              <li class="list-group-item">
                <a href="https://auth0.com/blog/json-web-token-signing-algorithms-overview/"
                   target="_blank">[9] - JSON Web Token (JWT) Signing Algorithms Overview</a>
              </li>
            </ul>
          </div>
        </div>
      </footer>

    </div>
    <script src="javascript/jquery.min.js"></script>

    <script src="javascript/bootstrap.min.js"></script>

    <script src="javascript/script.js"></script>
</body>

</html>