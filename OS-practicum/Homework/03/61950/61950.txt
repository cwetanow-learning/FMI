1. Проверява входните параметри и в случай, че не са подадени всички извежда съобщение за грешка и завършва с exit code 1

  if (argc < 3)
  {
    write(2, "Invalid parameters\n", 20);
    exit(11);
  }

2. Създава 2 помощни променливи от параметрите. 'dictionary' е името на файла-речник, а word е глобална променлива, която представлява търсената дума

  char *dictionary = argv[1];
  word = argv[2];

3. Опитва да отвори речника и създава файлов дескриптор, който записва в глобалната променлива 'fd'. При неуспех извежда съобщение за грешка и завършва с exit code 1.

  if ((fd = open(dictionary, O_RDONLY)) == -1)
  {
    write(2, "Invalid file\n", 14);
    exit(1);
  }

4. Чете до края на файла с 'lseek' и резултата, който е големината на файла в брой char-ове се записва в променлива 'end'. След това връща pointer-а на файловия дескриптор в началото на файла.

  int end;

  end = lseek(fd, 0, SEEK_END);

  lseek(fd, 0, SEEK_SET);

5. Измерва дължината на търсената дума и я записва в глобална променлива 'wordLen'

  wordLen = strlen(word);

6. Извиква функцията 'search' (описана в точка 7) с параметри 0 (началото на файла, първият символ) и стойността на 'end' (дължината на файла, последния символ).  

  search(0, end);

7. Функцията 'search' работи като двоично търсене. Получава параметри началото и края на интервала и сравнява търсеният елемент с този по средата на интервала. Ако съвпадат го изкарва на stdout, в противен случай коригира интервала и се извиква рекурсивно

7.1 Пресмята индекса на средният елемент и го присвоява на променливата 'middle'. След това прави проверка дали тази стойност съвпада с някоя от границите на интервала. Ако съвпада изкарва съобщение, че търсеният елемент не съществува и завършва с exit code 1.

  int middle = (start + end) / 2;
  if (middle == start || middle == end)
  {
    write(2, "Word not found\n", 16);
    exit(1);
  }

7.2 Мести pointer-а на файловия дескриптор на символа на позиция 'middle'. След това продължава да чете, докато достигне до нулев ('\0') символ. 

  lseek(fd, middle, SEEK_SET);

  char c;
  while (read(fd, &c, sizeof(c)))
  {
    if (c == '\0')
    {
      break;
    }
  }

7.3 Извиква се функцията 'compareToWord'. Тя извърта цикъл с дължина дължината на търсената дума, като пази в променливата 'i' позицията на текущия символ от търсената дума. На всяка итерация чете следващия символ от файла и го сравнява с текущия символ от търсената дума. Ако не съвпадат или прочетеният символ е символ за нов ред ('\n'), ги сравнява и връща 1 в случай, че 'c' е по-малък от 'word[i]' (символа в 'c' е по-надолу в ASCII таблицата от този в 'word[i]').
След извъртането по всички символи на търсената дума и ако все още съвпадат чете следващият символ от файла. В случай, че е символ за нов ред, е намерена търсената дума и връща 0.   

  int compareToWord()
  {
    char c;
    for (size_t i = 0; i < wordLen; i++)
    {
      read(fd, &c, sizeof(c));

      if (c != word[i] || c == '\n')
      {
        if (c < word[i])
        {
          return 1;
        }

        return -1;
      }
    }

    read(fd, &c, sizeof(c));
    if (c == '\n')
    {
      return 0;
    }

    return -1;
  }

7.4 Ако резултата е 0 (намерена е думата), се извиква функцията 'printResult', която чете следващите символи от файла, до достигане на нулев символ ('\0'), който показва началото на друга дума. Всички прочетени символи представляват описанието на търсената дума и се изкарват на stdout с 'write'.

  if (result == 0)
  {
    printResult();
  }

  void printResult()
  {
    char c;

    while (read(fd, &c, sizeof(c)))
    {
      if (c == '\0')
      {
        break;
      }

      write(1, &c, sizeof(c));
    }
  }

7.5 Ако не е намерена търсената дума, се извиква рекурсивно същата функция ('search'), но с променен интервал. Ако думата е по-малка, интервала се скъсява на първата половина на текущия (start - middle), в противен случай - да другата половина (middle - end)
  else if (result < 0)
  {
    search(start, middle);
  }
  else
  {
    search(middle, end);
  }